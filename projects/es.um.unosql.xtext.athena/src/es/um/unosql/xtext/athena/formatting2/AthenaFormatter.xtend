/*
 * generated by Xtext 2.16.0
 */
package es.um.unosql.xtext.athena.formatting2

import es.um.unosql.xtext.athena.athena.AthenaSchema
import es.um.unosql.xtext.athena.athena.AthenaPackage.Literals
import es.um.unosql.xtext.athena.athena.ShortEntityDecl
import es.um.unosql.xtext.athena.athena.RegularEntityDecl
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import es.um.unosql.xtext.athena.athena.DataType
import es.um.unosql.xtext.athena.athena.SimpleFeature
import es.um.unosql.xtext.athena.athena.SimpleReferenceTarget
import es.um.unosql.xtext.athena.athena.SimpleAggregationTarget
import es.um.unosql.xtext.athena.athena.FeatureSet
import es.um.unosql.xtext.athena.athena.Feature
import es.um.unosql.xtext.athena.athena.ComposedReference
import es.um.unosql.xtext.athena.athena.StructureLiteral
import es.um.unosql.xtext.athena.athena.FeatureSetDecl
import org.eclipse.xtext.formatting2.FormatterPreferenceKeys
import org.eclipse.xtext.preferences.MapBasedPreferenceValues
import java.util.HashMap
import es.um.unosql.xtext.athena.athena.ShortRelationshipDecl
import es.um.unosql.xtext.athena.athena.RegularRelationshipDecl
import es.um.unosql.xtext.athena.athena.VariationDecl
import es.um.unosql.xtext.athena.athena.SQLStructure
import es.um.unosql.xtext.athena.athena.SQLForeignConstraintDefinition
import es.um.unosql.xtext.athena.athena.SQLConstraintDefinition
import es.um.unosql.xtext.athena.athena.SQLReferenceTarget

class AthenaFormatter extends AbstractFormatter2
{
  // Not necessary apparently
  // @Inject extension AthenaGrammarAccess

  static val DEF_SEP = "  "

  def dispatch void format(AthenaSchema schema, extension IFormattableDocument document)
  {
    // Set two spaces for tabs.
    val newMap = new HashMap<String, String>
    newMap.put(FormatterPreferenceKeys.indentation.id, DEF_SEP)
    this.request.preferences = new MapBasedPreferenceValues(this.getPreferences(), newMap)

    val semRegion = schema.regionFor.feature(Literals.ATHENA_SCHEMA__NAME)

    if (!schema.imports.empty)
    {
      for (import : schema.imports)
        if (schema.imports.last === import)
          import.append[setNewLines(2)]
        else
          import.append[newLine]
    }

    if (schema.featureSets.empty && schema.entities.empty && schema.relationships.empty)
      semRegion.append[newLine]
    else
      semRegion.append[setNewLines(2)]

    for (fsetdecl : schema.featureSets)
    {
      fsetdecl.format
      fsetdecl.append[setNewLines(2)]
    }

    val schemaTypes = schema.entities + schema.relationships
    val lastType = schemaTypes.last
    for (schemaType : schemaTypes)
    {
      schemaType.format

      if (schemaType === lastType)
        schemaType.append[newLine]
      else
        schemaType.append[setNewLines(2)]
    }
  }

  def dispatch void format(FeatureSetDecl fset, extension IFormattableDocument document)
  {
    fset.structure.format
  }

  def dispatch void format(ShortEntityDecl sEntity, extension IFormattableDocument document)
  {
    sEntity.structure.format
  }

  def dispatch void format(RegularEntityDecl rEntity, extension IFormattableDocument document)
  {
    val firstPar = rEntity.regionFor.keywords("{").head
    val lastPar  = rEntity.regionFor.keywords("}").last

    interior(firstPar, lastPar)[indent]

    firstPar.prepend[newLine].append[newLine]
    lastPar.prepend[newLine]

    rEntity.common.format
    rEntity.common.append[newLine]

    for (variationDecl : rEntity.variations)
    {
      variationDecl.format
      variationDecl.append[newLine]
    }
  }

  def dispatch void format(ShortRelationshipDecl sRelationship, extension IFormattableDocument document)
  {
    sRelationship.structure.format
  }

  def dispatch void format(RegularRelationshipDecl rRelationship, extension IFormattableDocument document)
  {
    val firstPar = rRelationship.regionFor.keywords("{").head
    val lastPar  = rRelationship.regionFor.keywords("}").last

    interior(firstPar, lastPar)[indent]

    firstPar.prepend[newLine].append[newLine]
    lastPar.prepend[newLine]

    rRelationship.common.format
    rRelationship.common.append[newLine]

    for (variationDecl : rRelationship.variations)
    {
      variationDecl.format
      variationDecl.append[newLine]
    }
  }

  def dispatch void format(VariationDecl variation, extension IFormattableDocument document)
  {
    if (variation.structure !== null)
      variation.structure.format
  }

  def dispatch void format(StructureLiteral structLiteral, extension IFormattableDocument document)
  {
    val firstPar = structLiteral.regionFor.keywords("{").head
    val lastPar  = structLiteral.regionFor.keywords("}").last

    firstPar.prepend[newLine].append[newLine]
    lastPar.prepend[newLine]
    interior(firstPar, lastPar)[indent]

    if (structLiteral.spec !== null)
      structLiteral.spec.format
  }

  def dispatch void format(SQLStructure struct, extension IFormattableDocument document)
  {
    val init = struct.regionFor.keywords("SQL").head
    val begin = struct.regionFor.keywords("(").head
    val end  = struct.regionFor.keywords(")").last

    surround(init)[indent]
    surround(end)[indent]
    interior(init, end)[indent;indent]
    init.prepend[newLine]
    begin.append[newLine]
    end.prepend[newLine].append[noSpace]

    struct.regionFor.keywords(",").forEach[prepend[noSpace];append[newLine]]

    for (cdef : struct.definitions)
      cdef.format
  }

  def dispatch void format(SQLConstraintDefinition constraint, extension IFormattableDocument document)
  {
    constraint.regionFor.keywords("(").forEach[append[noSpace]]
    constraint.regionFor.keywords(")").forEach[prepend[noSpace]]
    constraint.regionFor.keywords(",").forEach[prepend[noSpace]]

    if (constraint instanceof SQLForeignConstraintDefinition)
      (constraint as SQLForeignConstraintDefinition).refs.format
  }

  def dispatch void format(SQLReferenceTarget ref, extension IFormattableDocument document)
  {
    ref.regionFor.keywords("(").forEach[append[noSpace]]
    ref.regionFor.keywords(")").forEach[prepend[noSpace]]
    ref.regionFor.keywords(",").forEach[prepend[noSpace]]
  }

  def dispatch void format(FeatureSet fSet, extension IFormattableDocument document)
  {
    fSet.regionFor.keywords(",").forEach[prepend[noSpace];append[newLine]]
    for (Feature feat : fSet.features)
      feat.format
  }

  def dispatch void format(ComposedReference ref, extension IFormattableDocument document)
  {
    ref.regionFor.keywords(",").forEach[prepend[noSpace]]
    ref.regionFor.keyword("(").append[noSpace]
    ref.regionFor.keyword(")").prepend[noSpace]
    ref.regionFor.keyword(":").prepend[noSpace]
    ref.target.regionFor.keyword("<").prepend[noSpace].append[noSpace]
    ref.target.regionFor.keyword(">").prepend[noSpace]
  }

  def dispatch void format(SimpleFeature sFeat, extension IFormattableDocument document)
  {
    sFeat.regionFor.keyword("+").append[noSpace]
    sFeat.regionFor.keyword("?").append[noSpace]
    sFeat.regionFor.keyword("!").append[noSpace]
    sFeat.regionFor.keyword(":").prepend[noSpace]
    sFeat.type.format
  }

  def dispatch void format(SimpleReferenceTarget ref, extension IFormattableDocument document)
  {
    ref.regionFor.keyword("<").prepend[noSpace].append[noSpace]
    ref.regionFor.keyword(">").prepend[noSpace]
    ref.regionFor.keyword("+").prepend[noSpace]
    ref.regionFor.keyword("*").prepend[noSpace]
  }

  def dispatch void format(SimpleAggregationTarget aggr, extension IFormattableDocument document)
  {
    aggr.regionFor.keyword("<").prepend[noSpace].append[noSpace]
    aggr.regionFor.keyword(">").prepend[noSpace]
    aggr.regionFor.keyword("+").prepend[noSpace]
    aggr.regionFor.keyword("*").prepend[noSpace]
  }

  def dispatch void format(DataType type, extension IFormattableDocument document)
  {
    type.regionFor.keyword("<").prepend[noSpace].append[noSpace]
    type.regionFor.keyword(">").prepend[noSpace]
    type.regionFor.keywords(",").forEach[prepend[noSpace]]
  }
}
