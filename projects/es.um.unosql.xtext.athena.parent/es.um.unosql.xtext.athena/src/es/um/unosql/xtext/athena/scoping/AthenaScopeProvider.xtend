/*
 * generated by Xtext 2.16.0
 */
package es.um.unosql.xtext.athena.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.impl.SimpleScope
import org.eclipse.xtext.EcoreUtil2
import es.um.unosql.xtext.athena.athena.AthenaSchema
import es.um.unosql.xtext.athena.athena.VariationDecl
import es.um.unosql.xtext.athena.athena.CommonSpec
import es.um.unosql.xtext.athena.athena.TopLevelStructureDefiningElementDecl
import es.um.unosql.xtext.athena.athena.Feature
import es.um.unosql.xtext.athena.athena.StructureExpr
import java.util.ArrayList
import es.um.unosql.xtext.athena.athena.SQLReferenceTarget
import es.um.unosql.xtext.athena.athena.SimpleReferenceTarget
import es.um.unosql.xtext.athena.athena.ComposedReferenceTarget
import es.um.unosql.xtext.athena.athena.SimpleAggregateTarget
import org.eclipse.xtext.naming.IQualifiedNameProvider
import com.google.inject.Inject

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class AthenaScopeProvider extends AbstractAthenaScopeProvider
{
  // https://stackoverflow.com/questions/36751250/how-to-turn-off-global-scope-in-xtext-2-9
  // https://bugs.eclipse.org/bugs/show_bug.cgi?id=491110

  @Inject
  IQualifiedNameProvider nameProvider

  override getScope(EObject context, EReference reference)
  {
    // context instanceof AthenaSchema is true when solving imports and when selecting parents. It is not easy to filter those cases.
    if (context instanceof TopLevelStructureDefiningElementDecl || context instanceof CommonSpec || context instanceof VariationDecl
      || context instanceof StructureExpr || context instanceof SQLReferenceTarget || context instanceof SimpleReferenceTarget
      || context instanceof ComposedReferenceTarget || context instanceof SimpleAggregateTarget || context instanceof Feature)
    {
      val rootElement = EcoreUtil2.getRootContainer(context) as AthenaSchema
      val resultElements = super.getScope(context, reference).allElements
      val qualifiedRoots = new ArrayList<String>()

      if (rootElement.imports !== null)
        qualifiedRoots.addAll(rootElement.imports.map[imported | nameProvider.getFullyQualifiedName(imported.importedNamespace).toString])

      qualifiedRoots.add(nameProvider.getFullyQualifiedName(rootElement).toString)

      return new SimpleScope(resultElements.filter[element | qualifiedRoots.contains(element.qualifiedName.segments.head)])
    }

    return super.getScope(context, reference)
  }
}
